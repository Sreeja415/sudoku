<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4x4 Sudoku Game</title>
    <!-- Tailwind CSS CDN for general styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom CSS for Sudoku grid layout and specific styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Aligns content to the top, allowing scroll */
            min-height: 100vh; /* Ensures it takes full height when content is short */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto; /* Allows vertical scrolling if content overflows */
        }

        #game-container {
            background-color: #ffffff;
            border-radius: 20px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 450px; /* Max width for larger screens */
            margin-top: 20px; /* Add some top margin to prevent being directly at the top */
            margin-bottom: 20px; /* Add some bottom margin */
        }

        h1 {
            color: #2d3748; /* Dark gray text */
            margin-bottom: 25px;
            font-size: 2.5rem; /* text-4xl */
            font-weight: 700; /* font-bold */
            text-align: center;
            background: linear-gradient(90deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #timer-display {
            font-size: 1.8rem;
            font-weight: 700;
            color: #ef4444; /* Red color for timer */
            margin-bottom: 15px;
            padding: 8px 15px;
            border-radius: 8px;
            background-color: #ffe4e6; /* Light red background */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        #sudoku-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 4 columns */
            grid-template-rows: repeat(4, 1fr); /* 4 rows */
            width: 100%;
            max-width: 350px; /* Sudoku grid max width */
            aspect-ratio: 1 / 1; /* Keep grid square */
            border: 3px solid #2d3748; /* main border */
            border-radius: 8px;
            overflow: hidden; /* Ensures rounded corners apply to content */
        }

        .cell {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #cbd5e0; /* light border for cells */
            box-sizing: border-box; /* Include padding and border in element's total width and height */
            background-color: #ffffff; /* cell background, changed to white for input contrast */
        }

        /* Thicker borders for 2x2 subgrids */
        .cell:nth-child(2n) { border-right: 2px solid #a0aec0; }
        .cell:nth-child(4n + 0) { border-right: 3px solid #2d3748 !important; } /* Right edge of 2x2 blocks */
        .cell:nth-child(4n + 1) { border-left: 3px solid #2d3748 !important; } /* Left edge of 2x2 blocks */

        /* Horizontal borders - adjusted logic for 4x4 */
        /* Top border for the entire grid */
        .cell:nth-child(n + 1):nth-child(-n + 4) { border-top: 3px solid #2d3748; }
        /* Thicker horizontal borders within the grid for subgrids (after rows 2 and 4) */
        .cell:nth-child(n + 5):nth-child(-n + 8) { border-top: 2px solid #a0aec0; } /* After first row block */
        .cell:nth-child(n + 9):nth-child(-n + 12) { border-top: 3px solid #2d3748; } /* After second row block */
        .cell:nth-child(n + 13):nth-child(-n + 16) { border-top: 2px solid #a0aec0; } /* After third row block */
        /* Bottom border for the entire grid */
        .cell:nth-child(n + 13):nth-child(-n + 16) { border-bottom: 3px solid #2d3748; }

        input {
            width: 80%;
            height: 80%;
            text-align: center;
            font-size: 1.5rem; /* text-2xl */
            font-weight: 600; /* semi-bold */
            color: #2d3748; /* dark gray */
            border: none;
            background: none;
            outline: none;
            box-sizing: border-box;
            border-radius: 5px;
            transition: background-color 0.2s ease;
        }

        input:hover {
            background-color: #e2e8f0; /* light hover background */
        }

        input:focus {
            background-color: #c3daec; /* focus background */
        }

        .fixed-cell {
            background-color: #edf2f7; /* fixed cell background */
            font-weight: bold;
            color: #2d3748; /* dark text for fixed cells */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem; /* text-2xl */
        }

        .fixed-cell input {
            cursor: default;
            pointer-events: none; /* Make input not clickable */
            background: none;
        }

        .controls {
            margin-top: 25px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 350px;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .btn:disabled {
            background: #a0aec0; /* Gray out when disabled */
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-primary {
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(145deg, #764ba2, #667eea);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
        }

        .btn-secondary {
            background: linear-gradient(145deg, #4299e1, #3182ce);
            color: white;
        }

        .btn-secondary:hover {
            background: linear-gradient(145deg, #3182ce, #4299e1);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
        }

        .btn-gemini {
            background: linear-gradient(145deg, #f6e05e, #d69e2e); /* Yellow/Orange gradient */
            color: #333;
        }

        .btn-gemini:hover {
            background: linear-gradient(145deg, #d69e2e, #f6e05e);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
        }
        
        #message-box {
            margin-top: 25px;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 1.1rem;
            text-align: center;
            width: 100%;
            max-width: 350px;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            color: #2d3748;
            background-color: #feebc8; /* Light orange for messages */
        }

        #message-box.show {
            opacity: 1;
            transform: translateY(0);
        }

        .message-success {
            background-color: #c6f6d5; /* light green */
            color: #2f855a; /* dark green text */
        }

        .message-error {
            background-color: #fed7d7; /* light red */
            color: #c53030; /* dark red text */
        }

        .message-info {
            background-color: #bee3f8; /* light blue */
            color: #2b6cb0; /* dark blue text */
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            #game-container {
                padding: 20px;
            }
            h1 {
                font-size: 1.75rem; /* text-3xl */
            }
            input, .fixed-cell {
                font-size: 1.25rem; /* text-xl */
            }
            .btn {
                width: 100%;
                padding: 10px 20px;
            }
            .controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>4x4 Sudoku</h1>
        <div id="timer-display">01:45</div> <!-- Timer display element -->
        <div id="sudoku-grid">
            <!-- Cells will be dynamically generated here by JavaScript -->
        </div>
        <div class="controls">
            <button id="new-game-btn" class="btn btn-primary">New Game</button>
            <button id="check-solution-btn" class="btn btn-secondary">Check Solution</button>
            <button id="get-hint-btn" class="btn btn-gemini">✨ Get Hint</button>
            <button id="get-tip-btn" class="btn btn-gemini">✨ Get Sudoku Tip</button>
            <button id="explain-step-btn" class="btn btn-gemini">✨ Explain Solution Step</button>
        </div>
        <div id="message-box"></div>
    </div>

    <script>
        // Sudoku Game Logic
        const SUDOKU_SIZE = 4;
        const SUBGRID_SIZE = 2; // For 4x4, subgrids are 2x2
        const TIME_LIMIT_SECONDS = 1 * 60 + 45; // Changed to 1 minute 45 seconds

        let board = []; // Current state of the board, including user inputs
        let solution = []; // The complete, valid solution for the current puzzle
        let initialBoard = []; // The initial puzzle with given numbers (fixed cells)
        let timerInterval; // Stores the interval ID for the timer
        let timeLeft = TIME_LIMIT_SECONDS; // Remaining time in seconds

        const sudokuGrid = document.getElementById('sudoku-grid');
        const newGameBtn = document.getElementById('new-game-btn');
        const checkSolutionBtn = document.getElementById('check-solution-btn');
        const getHintBtn = document.getElementById('get-hint-btn');
        const getTipBtn = document.getElementById('get-tip-btn');
        const explainStepBtn = document.getElementById('explain-step-btn');
        const messageBox = document.getElementById('message-box');
        const timerDisplay = document.getElementById('timer-display'); // Timer display element

        /**
         * Initializes a new Sudoku game.
         * Generates a new puzzle and renders it on the UI.
         */
        function newGame() {
            stopTimer(); // Stop any existing timer
            timeLeft = TIME_LIMIT_SECONDS; // Reset time
            updateTimerDisplay(); // Update display immediately
            startTimer(); // Start new timer

            // Generate a complete and valid 4x4 Sudoku solution
            solution = generateSudokuSolution(SUDOKU_SIZE);

            // Create a copy for the initial puzzle
            initialBoard = JSON.parse(JSON.stringify(solution));
            
            // Remove some numbers to create the puzzle for the user
            let cellsToRemove = 8; 
            let removedCount = 0;
            while (removedCount < cellsToRemove) {
                const row = Math.floor(Math.random() * SUDOKU_SIZE);
                const col = Math.floor(Math.random() * SUDOKU_SIZE);
                if (initialBoard[row][col] !== 0) { // If cell is not already empty
                    initialBoard[row][col] = 0; // Set to 0 to represent an empty cell
                    removedCount++;
                }
            }

            // Set the current board state to the generated puzzle
            board = JSON.parse(JSON.stringify(initialBoard));
            renderBoard();
            displayMessage('', false); // Clear any previous messages
            setAllInputsEnabled(true); // Ensure inputs are enabled at new game
            setButtonStates(false); // Enable all buttons for a new game
        }

        /**
         * Starts the game timer.
         */
        function startTimer() {
            stopTimer(); // Ensure no multiple timers are running
            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                if (timeLeft <= 0) {
                    stopTimer();
                    handleTimeUp();
                }
            }, 1000);
        }

        /**
         * Stops the game timer.
         */
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        /**
         * Updates the timer display in MM:SS format.
         */
        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            timerDisplay.textContent = formattedTime;

            if (timeLeft <= 60 && timeLeft > 0) { // Less than 1 minute remaining
                timerDisplay.style.color = '#dc2626'; // Darker red
            } else if (timeLeft <= 0) {
                timerDisplay.style.color = '#ef4444'; // Original red
            } else {
                timerDisplay.style.color = '#ef4444'; // Original red
            }
        }

        /**
         * Handles the event when the time limit expires.
         */
        function handleTimeUp() {
            displayMessage("Time's Up! Game Over.", true); // isError = true
            setAllInputsEnabled(false); // Disable all inputs
            setButtonStates(true); // Disable all control buttons
            newGameBtn.disabled = false; // Re-enable New Game button
        }


        /**
         * Generates a complete and valid Sudoku solution using backtracking.
         * @param {number} size - The size of the Sudoku grid (e.g., 4 for 4x4).
         * @returns {number[][]} A 2D array representing the solved Sudoku board.
         */
        function generateSudokuSolution(size) {
            let grid = Array(size).fill(0).map(() => Array(size).fill(0));
            solveSudoku(grid);
            return grid;
        }

        /**
         * Solves the Sudoku grid using a backtracking algorithm.
         * This function modifies the 'grid' array in place.
         * @param {number[][]} grid - The Sudoku board as a 2D array.
         * @returns {boolean} True if a solution is found, false otherwise.
         */
        function solveSudoku(grid) {
            for (let row = 0; row < SUDOKU_SIZE; row++) {
                for (let col = 0; col < SUDOKU_SIZE; col++) {
                    if (grid[row][col] === 0) { // If cell is empty
                        const numbers = Array.from({ length: SUDOKU_SIZE }, (_, i) => i + 1).sort(() => Math.random() - 0.5); // Shuffle numbers for variety

                        for (let num of numbers) {
                            if (isValidPlacement(grid, row, col, num)) {
                                grid[row][col] = num;

                                if (solveSudoku(grid)) { // Recursively try to solve
                                    return true;
                                } else {
                                    grid[row][col] = 0; // Backtrack: undo the choice
                                }
                            }
                        }
                        return false; // No valid number found for this cell
                    }
                }
            }
            return true; // All cells filled, solution found
        }

        /**
         * Checks if placing a number at a given position is valid according to Sudoku rules.
         * This function is primarily used by the solver.
         * @param {number[][]} grid - The current Sudoku board.
         * @param {number} row - The row index.
         * @param {number} col - The column index.
         * @param {number} num - The number to check.
         * @returns {boolean} True if the placement is valid, false otherwise.
         */
        function isValidPlacement(grid, row, col, num) {
            // Check row
            for (let x = 0; x < SUDOKU_SIZE; x++) {
                if (grid[row][x] === num && col !== x) {
                    return false;
                }
            }

            // Check column
            for (let x = 0; x < SUDOKU_SIZE; x++) {
                if (grid[x][col] === num && row !== x) {
                    return false;
                }
            }

            // Check subgrid
            const startRow = Math.floor(row / SUBGRID_SIZE) * SUBGRID_SIZE;
            const startCol = Math.floor(col / SUBGRID_SIZE) * SUBGRID_SIZE;
            for (let i = 0; i < SUBGRID_SIZE; i++) {
                for (let j = 0; j < SUBGRID_SIZE; j++) {
                    if (grid[startRow + i][startCol + j] === num && (startRow + i !== row || startCol + j !== col)) {
                        return false;
                    }
                }
            }
            return true;
        }

        /**
         * Renders the current state of the board to the HTML grid.
         */
        function renderBoard() {
            sudokuGrid.innerHTML = ''; // Clear previous grid
            for (let r = 0; r < SUDOKU_SIZE; r++) {
                for (let c = 0; c < SUDOKU_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.min = '1';
                    input.max = '4'; // Max value for 4x4 Sudoku
                    input.maxLength = '1'; // Visual hint
                    input.dataset.row = r;
                    input.dataset.col = c;
                    input.value = board[r][c] === 0 ? '' : board[r][c];

                    // Determine if the cell is part of the initial puzzle (fixed)
                    const isFixed = initialBoard[r][c] !== 0;
                    if (isFixed) {
                        input.readOnly = true; // Make fixed cells read-only
                        cell.classList.add('fixed-cell');
                    } else {
                        input.addEventListener('input', handleInput);
                    }
                    cell.appendChild(input);
                    sudokuGrid.appendChild(cell);
                }
            }
        }

        /**
         * Handles user input in a cell.
         * Validates the input to be a single digit between 1 and 4.
         * Updates the internal board state.
         * @param {Event} event - The input event.
         */
        function handleInput(event) {
            if (timeLeft <= 0) { // Prevent input if time is up
                event.target.value = ''; // Clear input if trying to type after time up
                return;
            }

            let value = event.target.value.trim();
            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);

            if (value === '') {
                board[row][col] = 0; // Set to 0 if empty
            } else {
                value = parseInt(value, 10);
                if (value >= 1 && value <= 4) { // Validate for 1-4
                    board[row][col] = value;
                } else {
                    event.target.value = ''; // Clear invalid input
                    board[row][col] = 0;
                    displayMessage('Please enter a number between 1 and 4.', true); // isError = true
                }
            }
            // Clear message after a short delay if it was an error message
            if (messageBox.classList.contains('message-error')) {
                setTimeout(() => displayMessage(''), 3000); // Clear message with empty string
            }
        }

        /**
         * Performs full validation of the current board based on Sudoku rules.
         * This function DOES NOT check against the generated 'solution' array,
         * only if the current board is a valid (but not necessarily unique) Sudoku.
         * @param {number[][]} currentBoard - The board state to validate.
         * @returns {boolean} True if the board is valid, false otherwise.
         * @returns {string} An error message if invalid, or empty string if valid.
         */
        function isValidSudokuBoard(currentBoard) {
            // Check rows
            for (let r = 0; r < SUDOKU_SIZE; r++) {
                const rowSet = new Set();
                for (let c = 0; c < SUDOKU_SIZE; c++) {
                    const num = currentBoard[r][c];
                    if (num === 0) continue; // Skip empty cells for rule validation
                    if (rowSet.has(num)) {
                        return `Duplicate '${num}' in Row ${r + 1}.`;
                    }
                    rowSet.add(num);
                }
            }

            // Check columns
            for (let c = 0; c < SUDOKU_SIZE; c++) {
                const colSet = new Set();
                for (let r = 0; r < SUDOKU_SIZE; r++) {
                    const num = currentBoard[r][c];
                    if (num === 0) continue; // Skip empty cells for rule validation
                    if (colSet.has(num)) {
                        return `Duplicate '${num}' in Column ${c + 1}.`;
                    }
                    colSet.add(num);
                }
            }

            // Check subgrids (2x2 for a 4x4 board)
            for (let startRow = 0; startRow < SUDOKU_SIZE; startRow += SUBGRID_SIZE) {
                for (let startCol = 0; startCol < SUDOKU_SIZE; startCol += SUBGRID_SIZE) {
                    const subgridSet = new Set();
                    for (let r = 0; r < SUBGRID_SIZE; r++) {
                        for (let c = 0; c < SUBGRID_SIZE; c++) {
                            const num = currentBoard[startRow + r][startCol + c];
                            if (num === 0) continue; // Skip empty cells for rule validation
                            if (subgridSet.has(num)) {
                                return `Duplicate '${num}' in 2x2 block at Row ${startRow + 1}, Col ${startCol + 1}.`;
                            }
                            subgridSet.add(num);
                        }
                    }
                }
            }
            return ""; // No errors found
        }

        /**
         * Checks if the current board state is a valid and complete Sudoku solution.
         * This function is called by the "Check Solution" button.
         * It first checks rules, then against the unique solution.
         */
        function checkSolution() {
            // Prevent checking if time is already up
            if (timeLeft <= 0) {
                displayMessage("Time's Up! You cannot check the solution.", true);
                return;
            }

            // 1. Check if the board is completely filled
            for (let r = 0; r < SUDOKU_SIZE; r++) {
                for (let c = 0; c < SUDOKU_SIZE; c++) {
                    if (board[r][c] === 0) {
                        displayMessage('The board is not complete. Fill all empty cells!', true); // isError = true
                        return;
                    }
                }
            }

            // 2. Validate Sudoku rules (rows, columns, subgrids) on the *current board*
            const validationError = isValidSudokuBoard(board);
            if (validationError) {
                displayMessage(`Oops! Your solution has an error: ${validationError} Please try again.`, true); // isError = true
                return;
            }

            // 3. If all rules are passed, then compare to the actual unique solution
            for (let r = 0; r < SUDOKU_SIZE; r++) {
                for (let c = 0; c < SUDOKU_SIZE; c++) {
                    if (board[r][c] !== solution[r][c]) {
                        displayMessage('Oops! Your solution is incorrect. It follows the rules, but is not THE solution for this puzzle. Try again.', true); // isError = true
                        return;
                    }
                }
            }

            displayMessage('Congratulations! You solved the Sudoku!', false, true); // isSuccess = true
            stopTimer(); // Stop timer when solved
            setAllInputsEnabled(false); // Disable all inputs
            setButtonStates(true); // Disable all control buttons
            newGameBtn.disabled = false; // Re-enable New Game button
        }
        
        /**
         * Displays a message in the message box.
         * @param {string} msg - The message to display.
         * @param {boolean} isError - True if it's an error message.
         * @param {boolean} isSuccess - True if it's a success message.
         * @param {boolean} isInfo - True if it's an informational message.
         * @param {boolean} isLoading - True if it's a loading message (adds spinner).
         */
        function displayMessage(msg, isError = false, isSuccess = false, isInfo = false, isLoading = false) {
            messageBox.textContent = msg; // Set text content first
            messageBox.classList.remove('show', 'message-error', 'message-success', 'message-info'); // Clear all previous classes
            messageBox.innerHTML = msg; // Reset innerHTML for spinner

            if (msg) {
                messageBox.classList.add('show');
                if (isError) {
                    messageBox.classList.add('message-error');
                } else if (isSuccess) {
                    messageBox.classList.add('message-success');
                } else if (isLoading) {
                    messageBox.classList.add('message-info'); // Loading can use info style
                    messageBox.innerHTML += ' <div class="loading-spinner"></div>'; // Add spinner
                } else {
                    messageBox.classList.add('message-info'); // Default to info
                }
            }
        }


        /**
         * Fetches a hint from the Gemini API.
         * The hint will suggest a valid number for an empty cell.
         */
        async function getHint() {
            // Prevent hint if time is up
            if (timeLeft <= 0) {
                displayMessage("Time's Up! Cannot get a hint.", true);
                return;
            }

            displayMessage('Getting a hint from Gemini AI...', false, false, false, true); // Show loading message
            // Disable buttons during API call
            setButtonStates(true);

            try {
                // Find an empty cell to ask the LLM about
                let emptyCell = null;
                for (let r = 0; r < SUDOKU_SIZE; r++) {
                    for (let c = 0; c < SUDOKU_SIZE; c++) {
                        if (board[r][c] === 0) {
                            emptyCell = { row: r, col: c };
                            break;
                        }
                    }
                    if (emptyCell) break;
                }

                if (!emptyCell) {
                    displayMessage('The board is already complete! No hints needed.', false, true); // isSuccess = true
                    return;
                }

                const prompt = `Here is a ${SUDOKU_SIZE}x${SUDOKU_SIZE} Sudoku board: ${JSON.stringify(board)}. 
                                The board has cells with numbers (1-${SUDOKU_SIZE}) and empty cells (represented by 0).
                                I need a hint for the empty cell at row ${emptyCell.row} and column ${emptyCell.col}.
                                Provide ONE valid number for this specific empty cell, and a brief reasoning for it.
                                Return the answer in JSON format, like this:
                                {
                                  "row": <row_index>,
                                  "col": <col_index>,
                                  "value": <valid_number>,
                                  "reasoning": "Brief explanation of why this number is valid."
                                }
                                Ensure the number is between 1 and ${SUDOKU_SIZE}.`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = {
                    contents: chatHistory,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "row": { "type": "NUMBER" },
                                "col": { "type": "NUMBER" },
                                "value": { "type": "NUMBER" },
                                "reasoning": { "type": "STRING" }
                            },
                            "propertyOrdering": ["row", "col", "value", "reasoning"]
                        }
                    }
                };

                const apiKey = ""; // Canvas will provide this.
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const jsonResponse = result.candidates[0].content.parts[0].text;
                    const hint = JSON.parse(jsonResponse);

                    // Validate hint structure and values
                    if (hint && typeof hint.row === 'number' && typeof hint.col === 'number' &&
                        typeof hint.value === 'number' && hint.value >= 1 && hint.value <= SUDOKU_SIZE) {
                        
                        // Check if the suggested hint is indeed valid according to Sudoku rules for the *current board*
                        // and if the cell is indeed empty.
                        if (board[hint.row][hint.col] === 0 && isValidPlacement(board, hint.row, hint.col, hint.value)) {
                            board[hint.row][hint.col] = hint.value; // Apply hint to the board
                            renderBoard(); // Re-render the board with the new hint

                            // Briefly highlight the hinted cell
                            const hintedCellInput = sudokuGrid.querySelector(`input[data-row="${hint.row}"][data-col="${hint.col}"]`);
                            if (hintedCellInput) {
                                hintedCellInput.style.backgroundColor = '#9ae6b4'; // Light green highlight
                                setTimeout(() => {
                                    // Revert color to original cell background based on whether it's fixed or not
                                    if (initialBoard[hint.row][hint.col] !== 0) {
                                        hintedCellInput.parentElement.classList.add('fixed-cell'); // Ensure fixed background
                                    } else {
                                        hintedCellInput.parentElement.style.backgroundColor = '#ffffff'; // Revert to white for non-fixed
                                    }
                                    hintedCellInput.style.backgroundColor = ''; // Clear direct background style
                                }, 1500);
                            }

                            displayMessage(`Hint: Put ${hint.value} at Row ${hint.row + 1}, Column ${hint.col + 1}. Reason: ${hint.reasoning}`, false, true); // isSuccess = true
                        } else {
                             displayMessage(`Gemini suggested a hint for row ${hint.row + 1}, column ${hint.col + 1} with value ${hint.value}, but it's not valid for this empty cell. Try another hint or check your board!`, true); // isError = true
                        }

                    } else {
                        displayMessage('Could not get a valid hint. Please try again or check the board state.', true); // isError = true
                        console.error('Invalid hint structure or cell already filled:', hint);
                    }
                } else {
                    displayMessage('Failed to get a hint from Gemini AI. Please try again.', true); // isError = true
                    console.error('Gemini API response did not contain candidates:', result);
                }
            } catch (error) {
                displayMessage('Error getting hint. Please check your network connection or try again.', true); // isError = true
                console.error('Error fetching hint from Gemini API:', error);
            } finally {
                // Re-enable buttons after API call
                setButtonStates(false);
            }
        }

        /**
         * Fetches a general Sudoku tip from the Gemini API.
         */
        async function getSudokuTip() {
            // Prevent tip if time is up
            if (timeLeft <= 0) {
                displayMessage("Time's Up! Cannot get a tip.", true);
                return;
            }

            displayMessage('Getting a Sudoku tip from Gemini AI...', false, false, false, true); // Show loading message
            // Disable buttons during API call
            setButtonStates(true);

            try {
                const prompt = `Give me a concise and helpful general tip or strategy for solving Sudoku puzzles. Keep it to one or two sentences.`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // Canvas will provide this.
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const tip = result.candidates[0].content.parts[0].text;
                    displayMessage(`Sudoku Tip: ${tip}`, false, false, true); // Display as info
                } else {
                    displayMessage('Failed to get a Sudoku tip. Please try again.', true); // isError = true
                    console.error('Gemini API response did not contain candidates for tip:', result);
                }
            } catch (error) {
                displayMessage('Error getting tip. Please check your network connection or try again.', true); // isError = true
                console.error('Error fetching tip from Gemini API:', error);
            } finally {
                // Re-enable buttons after API call
                setButtonStates(false);
            }
        }

        /**
         * Finds the first empty cell (value 0) on the board.
         * @returns {{row: number, col: number}|null} The coordinates of the first empty cell, or null if board is full.
         */
        function findFirstEmptyCell() {
            for (let r = 0; r < SUDOKU_SIZE; r++) {
                for (let c = 0; c < SUDOKU_SIZE; c++) {
                    if (board[r][c] === 0) {
                        return { row: r, col: c };
                    }
                }
            }
            return null; // Board is full
        }

        /**
         * Explains a logical step to solve an empty cell using the Gemini API.
         */
        async function explainSolutionStep() {
            // Prevent explanation if time is up
            if (timeLeft <= 0) {
                displayMessage("Time's Up! Cannot get solution explanation.", true);
                return;
            }

            const emptyCell = findFirstEmptyCell();
            if (!emptyCell) {
                displayMessage('The board is already full! No steps to explain.', false, false, true); // isInfo = true
                return;
            }

            const { row, col } = emptyCell;
            const correctValue = solution[row][col];

            displayMessage('Getting a solution step explanation from Gemini AI...', false, false, false, true); // Show loading message
            setButtonStates(true); // Disable all buttons

            try {
                const prompt = `I am playing a 4x4 Sudoku game. The current board state is:\n${JSON.stringify(board)}\n
                                The cell at row ${row}, column ${col} is currently empty. The correct number for this cell is ${correctValue}.
                                Explain a logical step or technique that a human player could use to deduce that the number for cell (${row}, ${col}) is ${correctValue}, without giving any other hints for other cells. Focus solely on how to solve THIS specific cell.
                                For example, "This is a naked single in its row," or "By looking at its 2x2 block, only ${correctValue} is possible."
                                Keep the explanation concise and focused on a single deduction step.`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // Canvas will provide this.
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const explanation = result.candidates[0].content.parts[0].text;
                    displayMessage(`Solution Step: ${explanation}`, false, false, true); // isInfo = true
                } else {
                    displayMessage('Could not retrieve a solution step explanation. Try playing a bit more!', true); // isError = true
                    console.error('Gemini API response did not contain candidates for explanation:', result);
                }
            } catch (error) {
                displayMessage('Failed to get a solution step. Check your connection!', true); // isError = true
                console.error('Error fetching explanation from Gemini API:', error);
            } finally {
                setButtonStates(false); // Re-enable all buttons
            }
        }


        /**
         * Sets the disabled state for all control buttons.
         * @param {boolean} disabled - True to disable, false to enable.
         */
        function setButtonStates(disabled) {
            newGameBtn.disabled = disabled;
            checkSolutionBtn.disabled = disabled;
            getHintBtn.disabled = disabled;
            getTipBtn.disabled = disabled;
            explainStepBtn.disabled = disabled;
        }

        /**
         * Enables or disables all input fields on the Sudoku board.
         * @param {boolean} enabled - True to enable, false to disable.
         */
        function setAllInputsEnabled(enabled) {
            const inputs = sudokuGrid.querySelectorAll('input');
            inputs.forEach(input => {
                // Only enable/disable if not a fixed cell
                const row = parseInt(input.dataset.row);
                const col = parseInt(input.dataset.col);
                if (initialBoard[row][col] === 0) { // Only affect non-fixed cells
                    input.readOnly = !enabled;
                    input.style.pointerEvents = enabled ? 'auto' : 'none';
                    input.style.cursor = enabled ? 'text' : 'default';
                }
            });
        }


        // Event Listeners
        newGameBtn.addEventListener('click', newGame);
        checkSolutionBtn.addEventListener('click', checkSolution);
        getHintBtn.addEventListener('click', getHint);
        getTipBtn.addEventListener('click', getSudokuTip);
        explainStepBtn.addEventListener('click', explainSolutionStep); // Event listener for the new button

        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', newGame);
    </script>
</body>
</html>
